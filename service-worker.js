// Service Worker for 8-Puzzle PWA
console.log('üöÄ Service Worker: Script charg√©');

const CACHE_NAME = '8puzzle-cache-v6';
const APP_VERSION = '1.4.0';

// Ressources critiques (n√©cessaires pour le fonctionnement hors ligne)
const CRITICAL_RESOURCES = [
  './',
  'index.html',
  'assets/css/style.css',
  'assets/js/script.js',
  'manifest.json',
  'logo.svg',
  'icons/icon-192x192.svg',
  'icons/icon-512x512.svg'
];

// Ressources secondaires (donn√©es de jeu - peuvent √™tre charg√©es √† la demande)
const SECONDARY_RESOURCES = [
  'assets/move_data/index.json',
  'assets/move_data/moves_0.json',
  'assets/move_data/moves_1.json',
  'assets/move_data/moves_2.json',
  'assets/move_data/moves_3.json',
  'assets/move_data/moves_4.json',
  'assets/move_data/moves_5.json',
  'assets/move_data/moves_6.json',
  'assets/move_data/moves_7.json',
  'assets/move_data/moves_8.json',
  'assets/move_data/moves_9.json',
  'assets/move_data/moves_10.json',
  'assets/move_data/moves_11.json',
  'assets/move_data/moves_12.json',
  'assets/move_data/moves_13.json',
  'assets/move_data/moves_14.json',
  'assets/move_data/moves_15.json',
  'assets/move_data/moves_16.json',
  'assets/move_data/moves_17.json',
  'assets/move_data/moves_18.json',
  'assets/move_data/moves_19.json',
  'assets/move_data/moves_20.json',
  'assets/move_data/moves_21.json',
  'assets/move_data/moves_22.json',
  'assets/move_data/moves_23.json',
  'assets/move_data/moves_24.json',
  'assets/move_data/moves_25.json',
  'assets/move_data/moves_26.json',
  'assets/move_data/moves_27.json',
  'assets/move_data/moves_28.json',
  'assets/move_data/moves_29.json',
  'assets/move_data/moves_30.json',
  'assets/move_data/moves_31.json'
];

// Ressources externes
const EXTERNAL_RESOURCES = [
  'https://cdn.jsdelivr.net/npm/chart.js'
];

// Installation du Service Worker
self.addEventListener('install', event => {
  console.log('üì¶ Service Worker: Installation d√©marr√©e');
  
  event.waitUntil(
    (async () => {
      try {
        const cache = await caches.open(CACHE_NAME);
        console.log('üìÇ Cache ouvert:', CACHE_NAME);
        
        // Mettre en cache les ressources critiques d'abord
        console.log('üîÑ Mise en cache des ressources critiques...');
        const criticalResults = await Promise.allSettled(
          CRITICAL_RESOURCES.map(async url => {
            try {
              const response = await fetch(url);
              if (!response.ok) {
                throw new Error(`HTTP ${response.status} for ${url}`);
              }
              await cache.put(url, response);
              console.log('‚úÖ Mis en cache:', url);
            } catch (error) {
              console.warn('‚ö†Ô∏è √âchec de mise en cache (critique):', url, error.message);
              throw error; // Bloquer l'installation si ressource critique √©choue
            }
          })
        );
        
        // V√©rifier que toutes les ressources critiques sont en cache
        const failedCritical = criticalResults.filter(result => result.status === 'rejected');
        if (failedCritical.length > 0) {
          console.error('‚ùå √âchec de mise en cache des ressources critiques');
          throw new Error('Critical resources failed to cache');
        }
        
        // Mettre en cache les ressources secondaires (non bloquant)
        console.log('üîÑ Mise en cache des ressources secondaires...');
        Promise.allSettled(
          SECONDARY_RESOURCES.map(async url => {
            try {
              const response = await fetch(url);
              if (response.ok) {
                await cache.put(url, response);
                console.log('‚úÖ Mis en cache (secondaire):', url);
              }
            } catch (error) {
              console.warn('‚ö†Ô∏è √âchec de mise en cache (secondaire):', url, error.message);
            }
          })
        );
        
        // Mettre en cache les ressources externes (non bloquant)
        console.log('üîÑ Mise en cache des ressources externes...');
        Promise.allSettled(
          EXTERNAL_RESOURCES.map(async url => {
            try {
              const response = await fetch(url);
              if (response.ok) {
                await cache.put(url, response);
                console.log('‚úÖ Mis en cache (externe):', url);
              }
            } catch (error) {
              console.warn('‚ö†Ô∏è √âchec de mise en cache (externe):', url, error.message);
            }
          })
        );
        
        console.log('üéâ Installation termin√©e avec succ√®s');
        
        // Forcer l'activation imm√©diate
        self.skipWaiting();
        
      } catch (error) {
        console.error('‚ùå Erreur lors de l\'installation:', error);
        throw error;
      }
    })()
  );
});

// Activation du Service Worker
self.addEventListener('activate', event => {
  console.log('üîÑ Service Worker: Activation d√©marr√©e');
  
  event.waitUntil(
    (async () => {
      try {
        // Nettoyer les anciens caches
        const cacheNames = await caches.keys();
        const deletePromises = cacheNames
          .filter(cacheName => cacheName.startsWith('8puzzle-cache-') && cacheName !== CACHE_NAME)
          .map(cacheName => {
            console.log('üóëÔ∏è Suppression de l\'ancien cache:', cacheName);
            return caches.delete(cacheName);
          });
        
        await Promise.all(deletePromises);
        
        // Prendre le contr√¥le de tous les clients
        await self.clients.claim();
        
        console.log('‚úÖ Service Worker activ√© et pr√™t');
        
        // Notifier tous les clients de la mise √† jour
        const clients = await self.clients.matchAll();
        clients.forEach(client => {
          client.postMessage({
            type: 'SW_ACTIVATED',
            version: APP_VERSION,
            cacheName: CACHE_NAME
          });
        });
        
      } catch (error) {
        console.error('‚ùå Erreur lors de l\'activation:', error);
      }
    })()
  );
});

// Interception des requ√™tes
self.addEventListener('fetch', event => {
  const url = new URL(event.request.url);
  
  // Ignorer les requ√™tes non-GET
  if (event.request.method !== 'GET') {
    return;
  }
  
  // Ignorer les requ√™tes Chrome DevTools
  if (url.protocol === 'chrome-extension:') {
    return;
  }
  
  event.respondWith(
    (async () => {
      try {
        // Strat√©gie: Cache First pour les ressources de l'app
        if (url.origin === location.origin || EXTERNAL_RESOURCES.includes(event.request.url)) {
          // Chercher d'abord dans le cache
          const cachedResponse = await caches.match(event.request);
          if (cachedResponse) {
            console.log('üì¶ Servi depuis le cache:', event.request.url);
            return cachedResponse;
          }
        }
        
        // Si pas en cache ou ressource externe, essayer le r√©seau
        console.log('üåê Tentative de r√©cup√©ration r√©seau:', event.request.url);
        const networkResponse = await fetch(event.request);
        
        // Mettre en cache les r√©ponses r√©ussies pour les ressources de l'app
        if (networkResponse.ok && url.origin === location.origin) {
          const cache = await caches.open(CACHE_NAME);
          await cache.put(event.request, networkResponse.clone());
          console.log('üíæ Mise en cache apr√®s r√©cup√©ration:', event.request.url);
        }
        
        return networkResponse;
        
      } catch (error) {
        console.warn('‚ö†Ô∏è Erreur de r√©cup√©ration pour:', event.request.url, error.message);
        
        // Fallback: essayer de servir depuis le cache m√™me pour les ressources non-origin
        const cachedResponse = await caches.match(event.request);
        if (cachedResponse) {
          console.log('üîÑ Fallback cache pour:', event.request.url);
          return cachedResponse;
        }
        
        // Si c'est une navigation et qu'on n'a rien, servir la page d'accueil
        if (event.request.mode === 'navigate') {
          const indexCache = await caches.match('./index.html');
          if (indexCache) {
            console.log('üè† Fallback vers index.html');
            return indexCache;
          }
        }
        
        // Derni√®re tentative: page d'erreur offline simple
        return new Response(
          `<!DOCTYPE html>
          <html>
          <head>
            <title>8-Puzzle - Hors ligne</title>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <style>
              body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
              .offline { color: #666; }
              .retry { margin-top: 20px; }
              button { padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; }
            </style>
          </head>
          <body>
            <div class="offline">
              <h1>üß© 8-Puzzle</h1>
              <h2>Mode hors ligne</h2>
              <p>Cette page n'est pas disponible hors ligne.</p>
              <div class="retry">
                <button onclick="location.reload()">R√©essayer</button>
                <button onclick="location.href='./'">Retour au jeu</button>
              </div>
            </div>
          </body>
          </html>`,
          {
            headers: {
              'Content-Type': 'text/html',
              'Cache-Control': 'no-cache'
            }
          }
        );
      }
    })()
  );
});

// √âcouter les messages des clients
self.addEventListener('message', event => {
  console.log('üì® Message re√ßu:', event.data);
  
  if (event.data && event.data.type === 'SKIP_WAITING') {
    console.log('‚è≠Ô∏è Passage forc√© √† la nouvelle version');
    self.skipWaiting();
  }
  
  if (event.data && event.data.type === 'GET_VERSION') {
    event.ports[0].postMessage({
      version: APP_VERSION,
      cacheName: CACHE_NAME
    });
  }
});

// Gestion des erreurs globales
self.addEventListener('error', event => {
  console.error('‚ùå Erreur Service Worker:', event.error);
});

self.addEventListener('unhandledrejection', event => {
  console.error('‚ùå Promise rejet√©e dans Service Worker:', event.reason);
});

console.log('üéØ Service Worker configur√© - Version:', APP_VERSION);
