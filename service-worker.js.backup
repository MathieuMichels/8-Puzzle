// Service Worker for 8-Puzzle PWA
console.log('ðŸš€ Service Worker: Script chargÃ©');

const CACHE_NAME = '8puzzle-cache-v6';
const APP_VERSION = '1.4.0';

// Ressources critiques (nÃ©cessaires pour le fonctionnement hors ligne)
const CRITICAL_RESOURCES = [
  './',
  'index.html',
  'assets/css/style.css',
  'assets/js/script.js',
  'manifest.json',
  'logo.svg',
  'icons/icon-192x192.svg',
  'icons/icon-512x512.svg'
];

// Ressources secondaires (donnÃ©es de jeu - peuvent Ãªtre chargÃ©es Ã  la demande)
const SECONDARY_RESOURCES = [
  'assets/move_data/index.json',
  'assets/move_data/moves_0.json',
  'assets/move_data/moves_1.json',
  'assets/move_data/moves_2.json',
  'assets/move_data/moves_3.json',
  'assets/move_data/moves_4.json',
  'assets/move_data/moves_5.json',
  'assets/move_data/moves_6.json',
  'assets/move_data/moves_7.json',
  'assets/move_data/moves_8.json',
  'assets/move_data/moves_9.json',
  'assets/move_data/moves_10.json',
  'assets/move_data/moves_11.json',
  'assets/move_data/moves_12.json',
  'assets/move_data/moves_13.json',
  'assets/move_data/moves_14.json',
  'assets/move_data/moves_15.json',
  'assets/move_data/moves_16.json',
  'assets/move_data/moves_17.json',
  'assets/move_data/moves_18.json',
  'assets/move_data/moves_19.json',
  'assets/move_data/moves_20.json',
  'assets/move_data/moves_21.json',
  'assets/move_data/moves_22.json',
  'assets/move_data/moves_23.json',
  'assets/move_data/moves_24.json',
  'assets/move_data/moves_25.json',
  'assets/move_data/moves_26.json',
  'assets/move_data/moves_27.json',
  'assets/move_data/moves_28.json',
  'assets/move_data/moves_29.json',
  'assets/move_data/moves_30.json',
  'assets/move_data/moves_31.json'
];

// Installation du service worker
self.addEventListener('install', event => {
  console.log('Service Worker: Installation en cours...');
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        console.log('Cache ouvert:', CACHE_NAME);
        // Construire les URLs complÃ¨tes avec le chemin de base
        const urlsToCache = baseUrlsToCache.map(url => {
          // Ne pas modifier les URLs absolutes (comme les CDNs)
          if (url.startsWith('http')) {
            return url;
          }
          return url;
        });
        console.log('Fichiers Ã  mettre en cache:', urlsToCache);
        return cache.addAll(urlsToCache)
          .then(() => {
            console.log('Tous les fichiers ont Ã©tÃ© mis en cache avec succÃ¨s');
          })
          .catch(error => {
            console.error('Erreur lors de la mise en cache:', error);
            throw error;
          });
      })
  );
  // Forcer l'activation immÃ©diate du nouveau service worker
  self.skipWaiting();
});

// Variable globale pour suivre l'Ã©tat de la connexion
let isOnline = true;

// Fonction pour dÃ©tecter l'Ã©tat de la connexion
function checkOnlineStatus() {
  return fetch('/').then(() => {
    isOnline = true;
    return true;
  }).catch(() => {
    isOnline = false;
    return false;
  });
}

// Notifier les clients de l'Ã©tat de connexion
function notifyClientsOfConnectionStatus(status) {
  self.clients.matchAll().then(clients => {
    clients.forEach(client => {
      client.postMessage({ type: status ? 'ONLINE' : 'OFFLINE' });
    });
  });
}

// Fonction pour logger avec timestamp
function logWithTimestamp(message, level = 'info') {
  const timestamp = new Date().toISOString();
  console[level](`[${timestamp}] SW: ${message}`);
}

// RÃ©cupÃ©ration des ressources
self.addEventListener('fetch', event => {
  const url = new URL(event.request.url);
  
  // Gestion spÃ©ciale pour l'URL racine ou index.html
  const isRootRequest = url.pathname === '/' || 
                        url.pathname === '/index.html' || 
                        url.pathname.endsWith('/index.html');

  // Si c'est une requÃªte de navigation (HTML)
  if (isRootRequest || event.request.mode === 'navigate' || 
      (event.request.method === 'GET' && 
       event.request.headers.get('accept') && 
       event.request.headers.get('accept').includes('text/html'))) {
       
    event.respondWith(
      // StratÃ©gie "Cache First" pour les pages HTML
      caches.match('index.html')
        .then(cachedResponse => {
          if (cachedResponse) {
            // Essayer de mettre Ã  jour en arriÃ¨re-plan
            fetch(event.request)
              .then(networkResponse => {
                if (networkResponse && networkResponse.status === 200) {
                  const responseToCache = networkResponse.clone();
                  caches.open(CACHE_NAME).then(cache => {
                    cache.put('index.html', responseToCache);
                  });
                }
              })
              .catch(() => {
                console.log('Mise Ã  jour en arriÃ¨re-plan Ã©chouÃ©e pour index.html');
              });
            return cachedResponse;
          }
          
          // Si pas de cache, essayer le rÃ©seau
          return fetch(event.request)
            .then(networkResponse => {
              if (networkResponse && networkResponse.status === 200) {
                const responseToCache = networkResponse.clone();
                caches.open(CACHE_NAME).then(cache => {
                  cache.put('index.html', responseToCache);
                });
              }
              return networkResponse;
            })
            .catch(() => {
              return new Response('Page non disponible hors ligne', {
                status: 503,
                statusText: 'Service Unavailable',
                headers: new Headers({ 'Content-Type': 'text/html; charset=utf-8' })
              });
            });
        })
    );
    return;
  }
  
  // Pour toutes les autres requÃªtes - StratÃ©gie "Cache First, Network Fallback"
  event.respondWith(
    caches.match(event.request)
      .then(cachedResponse => {
        if (cachedResponse) {
          // Ressource trouvÃ©e dans le cache
          console.log('Ressource servie depuis le cache:', event.request.url);
          return cachedResponse;
        }
        
        // Pas de cache, essayer le rÃ©seau
        return fetch(event.request)
          .then(networkResponse => {
            // VÃ©rifier que la rÃ©ponse est valide
            if (networkResponse && networkResponse.status === 200 && networkResponse.type === 'basic') {
              const responseToCache = networkResponse.clone();
              caches.open(CACHE_NAME).then(cache => {
                cache.put(event.request, responseToCache);
              });
            }
            return networkResponse;
          })
          .catch(error => {
            console.log('Erreur rÃ©seau pour:', event.request.url, error);
            // Pour les fichiers JSON, retourner une rÃ©ponse vide valide
            if (event.request.url.includes('.json')) {
              return new Response('{}', {
                status: 200,
                headers: new Headers({ 'Content-Type': 'application/json' })
              });
            }
            
            return new Response('Ressource non disponible hors ligne', {
              status: 503,
              statusText: 'Service Unavailable',
              headers: new Headers({ 'Content-Type': 'text/plain; charset=utf-8' })
            });
          });
      })
  );
});

// Mise Ã  jour du service worker
self.addEventListener('activate', event => {
  console.log('Service Worker: Activation en cours...');
  const cacheWhitelist = [CACHE_NAME];

  // Prendre le contrÃ´le immÃ©diatement de toutes les pages sans attendre la navigation
  event.waitUntil(
    Promise.all([
      // Supprimer les anciens caches
      caches.keys().then(cacheNames => {
        return Promise.all(
          cacheNames.map(cacheName => {
            if (cacheWhitelist.indexOf(cacheName) === -1) {
              console.log('Suppression de l\'ancien cache:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      }),
      // Prendre le contrÃ´le immÃ©diatement sans attendre le rafraÃ®chissement
      self.clients.claim().then(() => {
        console.log('Service Worker: ContrÃ´le pris sur toutes les pages');
        // Notifier les clients que le nouveau service worker est actif
        return self.clients.matchAll().then(clients => {
          clients.forEach(client => {
            client.postMessage({ type: 'SW_UPDATED' });
          });
        });
      })
    ])
  );
});

// Gestion des messages envoyÃ©s depuis la page
self.addEventListener('message', event => {
  console.log('Service Worker: Message reÃ§u:', event.data);
  
  if (event.data.action === 'skipWaiting') {
    console.log('Service Worker: skipWaiting demandÃ©');
    self.skipWaiting();
  }
  
  if (event.data.action === 'checkOnlineStatus') {
    checkOnlineStatus().then(status => {
      notifyClientsOfConnectionStatus(status);
    });
  }
});
